<!DOCTYPE html>
<html lang="en">
<head>
    <title>Heart Visualization</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="menu_style.css">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="./data/Postnatal_anatomical_structure/Postnatal_anatomical_structure.js"></script>
    <script src="./menuStyle.js"></script>
    <script src="findwikipediaInfos.js"></script>
    <script src="./libraries/jquery-3.5.1.min.js"></script>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/css/flag-icon.min.css" rel="stylesheet"/>
</head>

<body>
<!--surround the select box with a "custom-select" DIV element. Remember to set the width:-->
<div class="vertical-menu" style="width:700px; float:right; z-index: 100; position: absolute; right: 0;">
    <select id="Organs">
        <option value="Select organ:">Select part of organ:</option>
        <option value="Show all">Show all</option>
    </select>

    <select id="languageSelector"> </select>
</div>

<div id="glFullscreen">
    <canvas id="example"></canvas>
</div>
<!--

<div id="dat" class="dg ac"></div>
<div id="info">
    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - OBJLoader2 usage options<br>Use module
    workers with Chromium based browser (80+)
    <div id="feedback"></div>
</div>
-->

<script> // MENU

var x, i, j, l, ll, selElmnt, a, b, c;
/*look for any elements with the class "custom-select":*/
x = document.getElementsByClassName("custom-select");
l = x.length;
for (i = 0; i < l; i++) {
    selElmnt = x[i].getElementsByTagName("select")[0];
    ll = selElmnt.length;
    /*for each element, create a new DIV that will act as the selected item:*/
    a = document.createElement("DIV");
    a.setAttribute("class", "select-selected");
    a.innerHTML = selElmnt.options[selElmnt.selectedIndex].innerHTML;
    x[i].appendChild(a);
    /*for each element, create a new DIV that will contain the option list:*/
    b = document.createElement("DIV");
    b.setAttribute("class", "select-items select-hide");
    for (j = 1; j < ll; j++) {
        /*for each option in the original select element,
        create a new DIV that will act as an option item:*/
        c = document.createElement("DIV");
        c.innerHTML = selElmnt.options[j].innerHTML;
        c.addEventListener("click", function (e) {
            /*when an item is clicked, update the original select box,
            and the selected item:*/
            var y, i, k, s, h, sl, yl;
            s = this.parentNode.parentNode.getElementsByTagName("select")[0];
            sl = s.length;
            h = this.parentNode.previousSibling;
            for (i = 0; i < sl; i++) {
                if (s.options[i].innerHTML === this.innerHTML) {
                    s.selectedIndex = i;
                    h.innerHTML = this.innerHTML;
                    y = this.parentNode.getElementsByClassName("same-as-selected");
                    yl = y.length;
                    for (k = 0; k < yl; k++) {
                        y[k].removeAttribute("class");
                    }
                    this.setAttribute("class", "same-as-selected");
                    break;
                }
            }
            h.click();
        });
        b.appendChild(c);
    }
    x[i].appendChild(b);
    a.addEventListener("click", function (e) {
        /*when the select box is clicked, close any other select boxes,
        and open/close the current select box:*/
        e.stopPropagation();
        closeAllSelect(this);
        this.nextSibling.classList.toggle("select-hide");
        this.classList.toggle("select-arrow-active");
    });
}

function closeAllSelect(elmnt) {
    /*a function that will close all select boxes in the document,
    except the current select box:*/
    var x, y, i, xl, yl, arrNo = [];
    x = document.getElementsByClassName("select-items");
    y = document.getElementsByClassName("select-selected");
    xl = x.length;
    yl = y.length;
    for (i = 0; i < yl; i++) {
        if (elmnt === y[i]) {
            arrNo.push(i)
        } else {
            y[i].classList.remove("select-arrow-active");
        }
    }
    for (i = 0; i < xl; i++) {
        if (arrNo.indexOf(i)) {
            x[i].classList.add("select-hide");
        }
    }
}

/*if the user clicks anywhere outside the select box,
then close all select boxes:*/
document.addEventListener("click", closeAllSelect);


</script>
<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}


</script>

<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			vec4 getTexture( sampler2D texelToLinearTexture ) {

				return mapTexelToLinear( texture2D( texelToLinearTexture , vUv ) );

			}

			void main() {

				gl_FragColor = ( getTexture( baseTexture ) + vec4( 1.0 ) * getTexture( bloomTexture ) );

			}


</script>
<script type="module">

    'use strict';

    import * as THREE from './libraries/threejs/build/three.module.js';
    import {MeshPhongMaterial} from "./libraries/threejs/src/materials/MeshPhongMaterial.js";
    import {TrackballControls} from "./libraries/threejs/examples/jsm/controls/TrackballControls.js";
    import {OBJLoader2Parallel} from "./libraries/threejs/examples/jsm/loaders/OBJLoader2Parallel.js";
    import {EffectComposer} from './libraries/threejs/examples/jsm/postprocessing/EffectComposer.js';
    import {RenderPass} from './libraries/threejs/examples/jsm/postprocessing/RenderPass.js';
    import {ShaderPass} from './libraries/threejs/examples/jsm/postprocessing/ShaderPass.js';
    import {UnrealBloomPass} from './libraries/threejs/examples/jsm/postprocessing/UnrealBloomPass.js';


    let ENTIRE_SCENE = 0;
    let BLOOM_SCENE = 1;

    let bloomLayer = new THREE.Layers();
    bloomLayer.set(BLOOM_SCENE);
    let materials = {};
    let darkMaterial = new THREE.MeshBasicMaterial({color: "black"});
    let mouse = new THREE.Vector2();

    function getSelectedLanguage(newLanguage) {
        let sel = document.getElementById("languageSelector");
        return sel.options[sel.selectedIndex].text;
    }

    const WWOBJLoader2Example = function (elementToBindTo) {

        this.params = {
            exposure: 1,
            bloomStrength: 1.3,
            bloomThreshold: 0,
            bloomRadius: 0,
            scene: "Scene with Glow"
        };
        this.raycaster = new THREE.Raycaster();
        this.finalComposer = null;
        this.renderer = null;
        this.bloomComposer = null;
        this.canvas = elementToBindTo;
        this.aspectRatio = 1;
        this.recalcAspectRatio();

        this.scene = null;
        this.cameraDefaults = {
            posCamera: new THREE.Vector3(0.0, 175.0, 500.0),
            posCameraTarget: new THREE.Vector3(0, 0, 0),
            near: 0.1,
            far: 10000,
            fov: 45
        };
        this.camera = null;
        this.cameraTarget = this.cameraDefaults.posCameraTarget;

        this.controls = null;

        this.flatShading = false;
        this.doubleSide = true;
        this.useJsmWorker = false;
        this.loadCount = 6;

        this.pivot = null;
    };

    WWOBJLoader2Example.prototype = {
        // https://stackoverflow.com/questions/22896144/drop-down-menu-not-work
        constructor: WWOBJLoader2Example,

        initGL: function () {
            this.renderer = new THREE.WebGLRenderer({
                canvas: this.canvas,
                antialias: true,
                autoClear: true
            });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setClearColor(0x050505);
            this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);

            this.scene = new THREE.Scene();
            this.scene.traverse(this.disposeMaterial);

            this.camera = new THREE.PerspectiveCamera(this.cameraDefaults.fov, this.aspectRatio, this.cameraDefaults.near, this.cameraDefaults.far);
            this.resetCamera();
            this.controls = new TrackballControls(this.camera, this.renderer.domElement);

            let ambientLight = new THREE.AmbientLight(0x404040);
            let directionalLight1 = new THREE.DirectionalLight(0xC0C090);
            let directionalLight2 = new THREE.DirectionalLight(0xC0C090);

            directionalLight1.position.set(-100, -50, 100);
            directionalLight2.position.set(100, 50, -100);

            this.scene.add(directionalLight1);
            this.scene.add(directionalLight2);
            this.scene.add(ambientLight);

            this.pivot = new THREE.Object3D();
            this.pivot.name = 'Pivot';
            this.scene.add(this.pivot);

            let renderScene = new RenderPass(this.scene, this.camera);

            let bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = this.params.bloomThreshold;
            bloomPass.strength = this.params.bloomStrength;
            bloomPass.radius = this.params.bloomRadius;

            this.bloomComposer = new EffectComposer(this.renderer);
            this.bloomComposer.renderToScreen = false;
            this.bloomComposer.addPass(renderScene);
            this.bloomComposer.addPass(bloomPass);

            let finalPass = new ShaderPass(
                new THREE.ShaderMaterial({
                    uniforms: {
                        baseTexture: {value: null},
                        bloomTexture: {value: this.bloomComposer.renderTarget2.texture}
                    },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    defines: {}
                }), "baseTexture"
            );
            finalPass.needsSwap = true;

            this.finalComposer = new EffectComposer(this.renderer);
            this.finalComposer.addPass(renderScene);
            this.finalComposer.addPass(finalPass);


        },

        useLoadParallel: function (modelInfos, ID, organName) {
            let modelName = modelInfos.Filename;
            let color = modelInfos.Class;
            const testFolder = './data/Postnatal_anatomical_structure/';
            this._reportProgress({detail: {text: 'Loading: ' + organName}});

            let local = new THREE.Object3D();
            local.name = 'Pivot_WaltHead';
            local.position.set(0, 150, -1250);
            let scale = 1.0;
            local.scale.set(scale, scale, scale);
            this.pivot.add(local);

            let objLoader2Parallel = new OBJLoader2Parallel().setModelName(modelName)
                .setJsmWorker(this.useJsmWorker, new URL(OBJLoader2Parallel.DEFAULT_JSM_WORKER_PATH, window.location.href));

            let scope = this;

            let material = new MeshPhongMaterial({color: modelInfos.Class, opacity: 1.0, transparent: true});

            function callbackOnLoad(object3d, message) {
                object3d.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                    object3d.userData = {name: modelName};
                });
                local.add(object3d);

                scope._reportProgress({detail: {text: 'Loading of ' + modelName + ' completed: ' + message}});
                scope.finalize();
            }

            objLoader2Parallel.load(testFolder + modelName, callbackOnLoad);
            partsModels[ID] = local;
        },


        finalize: function () {
            this.loadCount--;
            if (this.loadCount === 0) {
                this._reportProgress({detail: {text: ''}});
            }
        },

        _reportProgress: function (event) {
            let output = '';
            if (event.detail !== null && event.detail !== undefined && event.detail.text) {
                output = event.detail.text;
            }
            console.log('Progress: ' + output);
        },

        resizeDisplayGL: function () {
            console.log("resizeDisplayGL")
            this.controls.handleResize();
            this.recalcAspectRatio();
            this.updateCamera();
            this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight, false);
            this.bloomComposer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
            this.finalComposer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
        },

        recalcAspectRatio: function () {
            this.aspectRatio = this.canvas.clientWidth / this.canvas.clientHeight;
        },

        resetCamera: function () {
            this.camera.position.copy(this.cameraDefaults.posCamera);
            this.cameraTarget.copy(this.cameraDefaults.posCameraTarget);
            this.updateCamera();
        },

        updateCamera: function () {
            this.camera.aspect = this.aspectRatio;
            this.camera.lookAt(this.cameraTarget);
            this.camera.updateProjectionMatrix();
        },

        renderBloom: function (mask) {

            if (mask === true) {
                this.scene.traverse(this.darkenNonBloomed);
                this.bloomComposer.render();
                this.scene.traverse(this.restoreMaterial);

            } else {

                this.camera.layers.set(BLOOM_SCENE);
                this.bloomComposer.render();
                this.camera.layers.set(ENTIRE_SCENE);
            }
        },

        darkenNonBloomed: function (obj) {
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {

                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        },

        restoreMaterial: function (obj) {
            if (materials[obj.uuid]) {

                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        },

        disposeMaterial: function (obj) {

            if (obj.material) {

                obj.material.dispose();

            }

        },

        render: function () {
            if (!this.renderer.autoClear) this.renderer.clear();
            this.controls.update();

            switch (this.params.scene) {

                case 'Scene only':
                    this.renderer.render(this.scene, this.camera);
                    break;
                case 'Glow only':
                    this.renderBloom(false);
                    break;
                case 'Scene with Glow':
                default:
                    // render scene with bloom
                    this.renderBloom(true);

                    // render the entire scene, then render bloom scene on top
                    this.finalComposer.render();
                    break;
            }
        },

        alterShading: function () {
            let scope = this;
            scope.flatShading = !scope.flatShading;
            console.log(scope.flatShading ? 'Enabling flat shading' : 'Enabling smooth shading');

            scope.traversalFunction = function (material) {
                material.flatShading = scope.flatShading;
                material.needsUpdate = true;
            };

            function scopeTraverse(object3d) {
                scope.traverseScene(object3d);
            }

            scope.pivot.traverse(scopeTraverse);
        },

        // TODO just double side
        alterDouble: function () {
            let scope = this;
            scope.doubleSide = !scope.doubleSide;
            console.log(scope.doubleSide ? 'Enabling THREE.DoubleSide materials' : 'Enabling THREE.FrontSide materials');

            scope.traversalFunction = function (material) {
                material.side = scope.doubleSide ? THREE.DoubleSide : THREE.FrontSide;
            };

            function scopeTraverse(object3d) {
                scope.traverseScene(object3d);
            }

            scope.pivot.traverse(scopeTraverse);
        },

        traverseScene: function (object3d) {
            if (Array.isArray(object3d.material)) {
                let currentMaterials = object3d.material.materials;
                for (let name in currentMaterials) {

                    if (currentMaterials.hasOwnProperty(name)) this.traversalFunction(currentMaterials[name]);
                }
            } else if (object3d.material) {
                this.traversalFunction(object3d.material);
            }
        },

        executeLoading: function () {
            let menu = document.getElementById("Organs");
            for (let currentObject in Postnatal_anatomical_structure) {
                let organName = Postnatal_anatomical_structure[currentObject].Filename.replace('.obj', '').split("_");
                this.useLoadParallel(Postnatal_anatomical_structure[currentObject], organName[0], organName[organName.length - 1]);
                let currentName = organName[organName.length - 1];
                if (!this.arrayContainsString(nameAndID, currentName)) {
                    menu.add(new Option(currentName, currentName), undefined);
                    nameAndID[organName[0]] = currentName;
                }
            }
        },

        arrayContainsString: function (myArray, value) {
            for (let i in myArray) {
                console.log()
                if (myArray[i] === value) {
                    return true;
                }
            }
            return false;
        },


        onDocumentMouseClick_object: function (event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; // + 0.31

            this.raycaster.setFromCamera(mouse, this.camera);
            let intersects = this.raycaster.intersectObjects(this.pivot.children, true);

            if (intersects.length > 0) {
                for (i in intersects) {
                    let object = intersects[i].object;
                    if (object.visible) {
                        object.visible = false;
                        break;
                    }
                }
                this.render();
            }
        }
    };

    let partsModels = [];
    let nameAndID = [];

    function onDocumentMouseClick(currentName) {
        app.onDocumentMouseClick_object(currentName);
    }

    var oldName = ""

    function emphasizeOrgan(currentName) {
        //TODO add glow
        changeAllMaterial(1.0);
        for (let ID in nameAndID) {
            if (nameAndID[ID] === currentName) {
                partsModels[ID].children[0].children[0].layers.toggle(BLOOM_SCENE);
            } else if (nameAndID[ID] === oldName) {
                partsModels[ID].children[0].children[0].layers.toggle(BLOOM_SCENE);
            }
        }
        oldName = currentName;
    }

    function changeAllMaterial(opacity) {
        let i = 0;
        for (let currentID in nameAndID) {
            i = i + 1;
            partsModels[currentID].children[0].children[0].visible = true;
            changeMaterial(currentID, opacity)
        }
    }

    function changeMaterial(ID, opacity) {
        partsModels[ID].layers.toggle(ENTIRE_SCENE);
        let materialColor = partsModels[ID].children[0].children[0].material.color; // "rgb(0,255,0)";
        let currentOpacity = partsModels[ID].children[0].children[0].material.opacity;

        //TODO if already the correct values donot redraw
        let material = new MeshPhongMaterial({
            color: materialColor,
            opacity: opacity,
            transparent: true,
            depthTest: true
        });
        partsModels[ID].children[0].children[0].material = material;
        partsModels[ID].children[0].children[0].geometry.uvsNeedUpdate = true;
        partsModels[ID].needsUpdate = true;
    }

    function changeMaterialOfObject(object, opacity) {
        let materialColor = object.material.color;
        let currentOpacity = object.material.opacity;

        let material = new MeshPhongMaterial({
            color: materialColor,
            opacity: opacity,
            transparent: true,
            depthTest: true
        });
        object.material = material;
        object.geometry.uvsNeedUpdate = true;
        object.needsUpdate = true;
    }

    function removeDivByID(divid) {
        $("div").remove(divid);
    }

    let element_selector = document.getElementById("Organs");
    let language_selector = document.getElementById("languageSelector");

    for (i in Postnatal_anatomical_structure[0].wikipediaInfos) {
        language_selector.add(new Option(i, i), undefined);
    }

    element_selector.addEventListener('change', updateValue);
    language_selector.addEventListener('change', updateValue);

    function updateValue(e) {
        if (e.target.value === "Select organ:" || e.target.value === "Show all") {
            resetMaterial();
            removeDivByID(".wikipediainfo")
        } else {
            emphasizeOrgan(e.target.value);
            let currentLanguage = getSelectedLanguage()
            console.log(currentLanguage);
            loadWikipediaPreview(e.target.value, currentLanguage); // currentLanguage
        }
    }

    function resetMaterial() {
        emphasizeOrgan("")
        changeAllMaterial(1.0)
    }

    let app = new WWOBJLoader2Example(document.getElementById('example'));

    function resizeWindow() {
        app.resizeDisplayGL();
    }

    function render() {
        requestAnimationFrame(render);
        app.render();
    }

    window.addEventListener('resize', resizeWindow, false);
    window.addEventListener('click', onDocumentMouseClick, false);

    console.log('Starting initialisation phase...');
    app.initGL();
    app.resizeDisplayGL();

    // kick render loop
    render();
    app.executeLoading();
</script>

</body>
</html>
